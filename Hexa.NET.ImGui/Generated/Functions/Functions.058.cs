// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyNode(uint srcNodeId, uint dstNodeId, ref ImVector<int> outNodeRemapPairs)
		{
			fixed (ImVector<int>* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				DockBuilderCopyNodeNative(srcNodeId, dstNodeId, (ImVector<int>*)poutNodeRemapPairs);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockBuilderCopyWindowSettingsNative(byte* srcName, byte* dstName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)vt[1196])(srcName, dstName);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1196])((nint)srcName, (nint)dstName);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName)
		{
			DockBuilderCopyWindowSettingsNative(srcName, dstName);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, byte* dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				DockBuilderCopyWindowSettingsNative((byte*)psrcName, dstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* pdstName = dstName)
			{
				DockBuilderCopyWindowSettingsNative(srcName, (byte*)pdstName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DockBuilderCopyWindowSettingsNative(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				fixed (byte* pdstName = dstName)
				{
					DockBuilderCopyWindowSettingsNative((byte*)psrcName, (byte*)pdstName);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			DockBuilderCopyWindowSettingsNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DockBuilderFinishNative(uint nodeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)vt[1197])(nodeId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)vt[1197])(nodeId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DockBuilderFinish(uint nodeId)
		{
			DockBuilderFinishNative(nodeId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PushFocusScopeNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)vt[1198])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)vt[1198])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFocusScope(uint id)
		{
			PushFocusScopeNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopFocusScopeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1199])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1199])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopFocusScope()
		{
			PopFocusScopeNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint GetCurrentFocusScopeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)vt[1200])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)vt[1200])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCurrentFocusScope()
		{
			uint ret = GetCurrentFocusScopeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsDragDropActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1201])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1201])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDragDropActive()
		{
			byte ret = IsDragDropActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginDragDropTargetCustomNative(ImRect bb, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)vt[1202])(bb, id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)vt[1202])(bb, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginDragDropTargetCustom(ImRect bb, uint id)
		{
			byte ret = BeginDragDropTargetCustomNative(bb, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void ClearDragDropNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1203])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1203])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearDragDrop()
		{
			ClearDragDropNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsDragDropPayloadBeingAcceptedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[1204])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[1204])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDragDropPayloadBeingAccepted()
		{
			byte ret = IsDragDropPayloadBeingAcceptedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void RenderDragDropTargetRectNative(ImRect bb, ImRect itemClipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, ImRect, void>)vt[1205])(bb, itemClipRect);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, ImRect, void>)vt[1205])(bb, itemClipRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderDragDropTargetRect(ImRect bb, ImRect itemClipRect)
		{
			RenderDragDropTargetRectNative(bb, itemClipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTypingSelectRequest* GetTypingSelectRequestNative(ImGuiTypingSelectFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectFlags, ImGuiTypingSelectRequest*>)vt[1206])(flags);
			#else
			return (ImGuiTypingSelectRequest*)((delegate* unmanaged[Cdecl]<ImGuiTypingSelectFlags, nint>)vt[1206])(flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTypingSelectRequestPtr GetTypingSelectRequest(ImGuiTypingSelectFlags flags)
		{
			ImGuiTypingSelectRequestPtr ret = GetTypingSelectRequestNative(flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int TypingSelectFindMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*>, void*, int, int>)vt[1207])(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)vt[1207])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData, navItemIdx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int TypingSelectFindNextSingleCharMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*>, void*, int, int>)vt[1208])(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)vt[1208])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData, navItemIdx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			int ret = TypingSelectFindNextSingleCharMatchNative(req, itemsCount, getItemNameFunc, userData, navItemIdx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindNextSingleCharMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, int, byte*> getItemNameFunc, void* userData, int navItemIdx)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindNextSingleCharMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData, navItemIdx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int TypingSelectFindBestLeadingMatchNative(ImGuiTypingSelectRequest* req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*> getItemNameFunc, void* userData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectRequest*, int, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*>, void*, int>)vt[1209])(req, itemsCount, getItemNameFunc, userData);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)vt[1209])((nint)req, itemsCount, (nint)getItemNameFunc, (nint)userData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequestPtr req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*> getItemNameFunc, void* userData)
		{
			int ret = TypingSelectFindBestLeadingMatchNative(req, itemsCount, getItemNameFunc, userData);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TypingSelectFindBestLeadingMatch(ref ImGuiTypingSelectRequest req, int itemsCount, delegate*<ImGuiTypingSelectRequest*, int, delegate*<void*, int, byte*>, void*, byte*> getItemNameFunc, void* userData)
		{
			fixed (ImGuiTypingSelectRequest* preq = &req)
			{
				int ret = TypingSelectFindBestLeadingMatchNative((ImGuiTypingSelectRequest*)preq, itemsCount, getItemNameFunc, userData);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginBoxSelectNative(ImRect scopeRect, ImGuiWindow* window, uint boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, ImGuiWindow*, uint, ImGuiMultiSelectFlags, byte>)vt[1210])(scopeRect, window, boxSelectId, msFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, nint, uint, ImGuiMultiSelectFlags, byte>)vt[1210])(scopeRect, (nint)window, boxSelectId, msFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginBoxSelect(ImRect scopeRect, ImGuiWindowPtr window, uint boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			byte ret = BeginBoxSelectNative(scopeRect, window, boxSelectId, msFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginBoxSelect(ImRect scopeRect, ref ImGuiWindow window, uint boxSelectId, ImGuiMultiSelectFlags msFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = BeginBoxSelectNative(scopeRect, (ImGuiWindow*)pwindow, boxSelectId, msFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void EndBoxSelectNative(ImRect scopeRect, ImGuiMultiSelectFlags msFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, ImGuiMultiSelectFlags, void>)vt[1211])(scopeRect, msFlags);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, ImGuiMultiSelectFlags, void>)vt[1211])(scopeRect, msFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndBoxSelect(ImRect scopeRect, ImGuiMultiSelectFlags msFlags)
		{
			EndBoxSelectNative(scopeRect, msFlags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectItemHeaderNative(uint id, bool* pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, bool*, ImGuiButtonFlags*, void>)vt[1212])(id, pSelected, pButtonFlags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)vt[1212])(id, (nint)pSelected, (nint)pButtonFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemHeader(uint id, bool* pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			MultiSelectItemHeaderNative(id, pSelected, pButtonFlags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemHeader(uint id, ref bool pSelected, ImGuiButtonFlags* pButtonFlags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				MultiSelectItemHeaderNative(id, (bool*)ppSelected, pButtonFlags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectItemFooterNative(uint id, bool* pSelected, bool* pPressed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, bool*, bool*, void>)vt[1213])(id, pSelected, pPressed);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)vt[1213])(id, (nint)pSelected, (nint)pPressed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, bool* pSelected, bool* pPressed)
		{
			MultiSelectItemFooterNative(id, pSelected, pPressed);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, ref bool pSelected, bool* pPressed)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				MultiSelectItemFooterNative(id, (bool*)ppSelected, pPressed);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, bool* pSelected, ref bool pPressed)
		{
			fixed (bool* ppPressed = &pPressed)
			{
				MultiSelectItemFooterNative(id, pSelected, (bool*)ppPressed);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectItemFooter(uint id, ref bool pSelected, ref bool pPressed)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				fixed (bool* ppPressed = &pPressed)
				{
					MultiSelectItemFooterNative(id, (bool*)ppSelected, (bool*)ppPressed);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectAddSetAllNative(ImGuiMultiSelectTempData* ms, byte selected)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, byte, void>)vt[1214])(ms, selected);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)vt[1214])((nint)ms, selected);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetAll(ImGuiMultiSelectTempDataPtr ms, bool selected)
		{
			MultiSelectAddSetAllNative(ms, selected ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetAll(ref ImGuiMultiSelectTempData ms, bool selected)
		{
			fixed (ImGuiMultiSelectTempData* pms = &ms)
			{
				MultiSelectAddSetAllNative((ImGuiMultiSelectTempData*)pms, selected ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void MultiSelectAddSetRangeNative(ImGuiMultiSelectTempData* ms, byte selected, int rangeDir, long firstItem, long lastItem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, byte, int, long, long, void>)vt[1215])(ms, selected, rangeDir, firstItem, lastItem);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, int, long, long, void>)vt[1215])((nint)ms, selected, rangeDir, firstItem, lastItem);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetRange(ImGuiMultiSelectTempDataPtr ms, bool selected, int rangeDir, long firstItem, long lastItem)
		{
			MultiSelectAddSetRangeNative(ms, selected ? (byte)1 : (byte)0, rangeDir, firstItem, lastItem);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MultiSelectAddSetRange(ref ImGuiMultiSelectTempData ms, bool selected, int rangeDir, long firstItem, long lastItem)
		{
			fixed (ImGuiMultiSelectTempData* pms = &ms)
			{
				MultiSelectAddSetRangeNative((ImGuiMultiSelectTempData*)pms, selected ? (byte)1 : (byte)0, rangeDir, firstItem, lastItem);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiBoxSelectState* GetBoxSelectStateNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiBoxSelectState*>)vt[1216])(id);
			#else
			return (ImGuiBoxSelectState*)((delegate* unmanaged[Cdecl]<uint, nint>)vt[1216])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiBoxSelectStatePtr GetBoxSelectState(uint id)
		{
			ImGuiBoxSelectStatePtr ret = GetBoxSelectStateNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiMultiSelectState* GetMultiSelectStateNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiMultiSelectState*>)vt[1217])(id);
			#else
			return (ImGuiMultiSelectState*)((delegate* unmanaged[Cdecl]<uint, nint>)vt[1217])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectStatePtr GetMultiSelectState(uint id)
		{
			ImGuiMultiSelectStatePtr ret = GetMultiSelectStateNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SetWindowClipRectBeforeSetChannelNative(ImGuiWindow* window, ImRect clipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, void>)vt[1218])(window, clipRect);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)vt[1218])((nint)window, clipRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowClipRectBeforeSetChannel(ImGuiWindowPtr window, ImRect clipRect)
		{
			SetWindowClipRectBeforeSetChannelNative(window, clipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowClipRectBeforeSetChannelNative((ImGuiWindow*)pwindow, clipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void BeginColumnsNative(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, ImGuiOldColumnFlags, void>)vt[1219])(strId, count, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImGuiOldColumnFlags, void>)vt[1219])((nint)strId, count, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			BeginColumnsNative(strId, count, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(ReadOnlySpan<byte> strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				BeginColumnsNative((byte*)pstrId, count, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BeginColumnsNative(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void EndColumnsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1220])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1220])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndColumns()
		{
			EndColumnsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PushColumnClipRectNative(int columnIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1221])(columnIndex);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1221])(columnIndex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushColumnClipRect(int columnIndex)
		{
			PushColumnClipRectNative(columnIndex);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PushColumnsBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1222])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1222])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushColumnsBackground()
		{
			PushColumnsBackgroundNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopColumnsBackgroundNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1223])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1223])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopColumnsBackground()
		{
			PopColumnsBackgroundNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint GetColumnsIDNative(byte* strId, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, uint>)vt[1224])(strId, count);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)vt[1224])((nint)strId, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(byte* strId, int count)
		{
			uint ret = GetColumnsIDNative(strId, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				uint ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(ReadOnlySpan<byte> strId, int count)
		{
			fixed (byte* pstrId = strId)
			{
				uint ret = GetColumnsIDNative((byte*)pstrId, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetColumnsIDNative(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiOldColumns* FindOrCreateColumnsNative(ImGuiWindow* window, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, uint, ImGuiOldColumns*>)vt[1225])(window, id);
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)vt[1225])((nint)window, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr FindOrCreateColumns(ImGuiWindowPtr window, uint id)
		{
			ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative(window, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr FindOrCreateColumns(ref ImGuiWindow window, uint id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumnsPtr ret = FindOrCreateColumnsNative((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float GetColumnOffsetFromNormNative(ImGuiOldColumns* columns, float offsetNorm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, float, float>)vt[1226])(columns, offsetNorm);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float>)vt[1226])((nint)columns, offsetNorm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnOffsetFromNorm(ImGuiOldColumnsPtr columns, float offsetNorm)
		{
			float ret = GetColumnOffsetFromNormNative(columns, offsetNorm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnOffsetFromNormNative((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float GetColumnNormFromOffsetNative(ImGuiOldColumns* columns, float offset)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, float, float>)vt[1227])(columns, offset);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float>)vt[1227])((nint)columns, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnNormFromOffset(ImGuiOldColumnsPtr columns, float offset)
		{
			float ret = GetColumnNormFromOffsetNative(columns, offset);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = GetColumnNormFromOffsetNative((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableOpenContextMenuNative(int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[1228])(columnN);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[1228])(columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableOpenContextMenu(int columnN)
		{
			TableOpenContextMenuNative(columnN);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSetColumnWidthNative(int columnN, float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[1229])(columnN, width);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)vt[1229])(columnN, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnWidth(int columnN, float width)
		{
			TableSetColumnWidthNative(columnN, width);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSetColumnSortDirectionNative(int columnN, ImGuiSortDirection sortDirection, byte appendToSortSpecs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ImGuiSortDirection, byte, void>)vt[1230])(columnN, sortDirection, appendToSortSpecs);
			#else
			((delegate* unmanaged[Cdecl]<int, ImGuiSortDirection, byte, void>)vt[1230])(columnN, sortDirection, appendToSortSpecs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs)
		{
			TableSetColumnSortDirectionNative(columnN, sortDirection, appendToSortSpecs ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int TableGetHoveredRowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[1231])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[1231])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TableGetHoveredRow()
		{
			int ret = TableGetHoveredRowNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float TableGetHeaderRowHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[1232])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[1232])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetHeaderRowHeight()
		{
			float ret = TableGetHeaderRowHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float TableGetHeaderAngledMaxLabelWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[1233])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[1233])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetHeaderAngledMaxLabelWidth()
		{
			float ret = TableGetHeaderAngledMaxLabelWidthNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TablePushBackgroundChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1234])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1234])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TablePushBackgroundChannel()
		{
			TablePushBackgroundChannelNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TablePopBackgroundChannelNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1235])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1235])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TablePopBackgroundChannel()
		{
			TablePopBackgroundChannelNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableAngledHeadersRowExNative(uint rowId, float angle, float maxLabelWidth, ImGuiTableHeaderData* data, int dataCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, ImGuiTableHeaderData*, int, void>)vt[1236])(rowId, angle, maxLabelWidth, data, dataCount);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, nint, int, void>)vt[1236])(rowId, angle, maxLabelWidth, (nint)data, dataCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableAngledHeadersRowEx(uint rowId, float angle, float maxLabelWidth, ImGuiTableHeaderDataPtr data, int dataCount)
		{
			TableAngledHeadersRowExNative(rowId, angle, maxLabelWidth, data, dataCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableAngledHeadersRowEx(uint rowId, float angle, float maxLabelWidth, ref ImGuiTableHeaderData data, int dataCount)
		{
			fixed (ImGuiTableHeaderData* pdata = &data)
			{
				TableAngledHeadersRowExNative(rowId, angle, maxLabelWidth, (ImGuiTableHeaderData*)pdata, dataCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTable* GetCurrentTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*>)vt[1237])();
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<nint>)vt[1237])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTablePtr GetCurrentTable()
		{
			ImGuiTablePtr ret = GetCurrentTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTable* TableFindByIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiTable*>)vt[1238])(id);
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<uint, nint>)vt[1238])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTablePtr TableFindByID(uint id)
		{
			ImGuiTablePtr ret = TableFindByIDNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginTableExNative(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, int, ImGuiTableFlags, Vector2, float, byte>)vt[1239])(name, id, columnsCount, flags, outerSize, innerWidth);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, int, ImGuiTableFlags, Vector2, float, byte>)vt[1239])((nint)name, id, columnsCount, flags, outerSize, innerWidth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = BeginTableExNative(name, id, columnsCount, flags, outerSize, innerWidth);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginTableExNative((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginTableExNative(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableBeginInitMemoryNative(ImGuiTable* table, int columnsCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, int, void>)vt[1240])(table, columnsCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[1240])((nint)table, columnsCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginInitMemory(ImGuiTablePtr table, int columnsCount)
		{
			TableBeginInitMemoryNative(table, columnsCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginInitMemoryNative((ImGuiTable*)ptable, columnsCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableBeginApplyRequestsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1241])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1241])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginApplyRequests(ImGuiTablePtr table)
		{
			TableBeginApplyRequestsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginApplyRequestsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSetupDrawChannelsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1242])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1242])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupDrawChannels(ImGuiTablePtr table)
		{
			TableSetupDrawChannelsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetupDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableUpdateLayoutNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1243])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1243])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateLayout(ImGuiTablePtr table)
		{
			TableUpdateLayoutNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateLayoutNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableUpdateBordersNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1244])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1244])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateBorders(ImGuiTablePtr table)
		{
			TableUpdateBordersNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateBordersNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableUpdateColumnsWeightFromWidthNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1245])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1245])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateColumnsWeightFromWidth(ImGuiTablePtr table)
		{
			TableUpdateColumnsWeightFromWidthNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableUpdateColumnsWeightFromWidthNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableDrawBordersNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1246])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1246])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawBorders(ImGuiTablePtr table)
		{
			TableDrawBordersNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawBordersNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableDrawDefaultContextMenuNative(ImGuiTable* table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableFlags, void>)vt[1247])(table, flagsForSectionToDisplay);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiTableFlags, void>)vt[1247])((nint)table, flagsForSectionToDisplay);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawDefaultContextMenu(ImGuiTablePtr table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			TableDrawDefaultContextMenuNative(table, flagsForSectionToDisplay);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableDrawDefaultContextMenu(ref ImGuiTable table, ImGuiTableFlags flagsForSectionToDisplay)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableDrawDefaultContextMenuNative((ImGuiTable*)ptable, flagsForSectionToDisplay);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte TableBeginContextMenuPopupNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, byte>)vt[1248])(table);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[1248])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TableBeginContextMenuPopup(ImGuiTablePtr table)
		{
			byte ret = TableBeginContextMenuPopupNative(table);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TableBeginContextMenuPopup(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte ret = TableBeginContextMenuPopupNative((ImGuiTable*)ptable);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableMergeDrawChannelsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1249])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1249])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableMergeDrawChannels(ImGuiTablePtr table)
		{
			TableMergeDrawChannelsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableMergeDrawChannelsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTableInstanceData* TableGetInstanceDataNative(ImGuiTable* table, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, ImGuiTableInstanceData*>)vt[1250])(table, instanceNo);
			#else
			return (ImGuiTableInstanceData*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[1250])((nint)table, instanceNo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ImGuiTablePtr table, int instanceNo)
		{
			ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative(table, instanceNo);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceDataPtr ret = TableGetInstanceDataNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint TableGetInstanceIDNative(ImGuiTable* table, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, uint>)vt[1251])(table, instanceNo);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)vt[1251])((nint)table, instanceNo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TableGetInstanceID(ImGuiTablePtr table, int instanceNo)
		{
			uint ret = TableGetInstanceIDNative(table, instanceNo);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TableGetInstanceID(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				uint ret = TableGetInstanceIDNative((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSortSpecsSanitizeNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1252])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1252])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSortSpecsSanitize(ImGuiTablePtr table)
		{
			TableSortSpecsSanitizeNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSortSpecsSanitize(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsSanitizeNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSortSpecsBuildNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1253])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1253])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSortSpecsBuild(ImGuiTablePtr table)
		{
			TableSortSpecsBuildNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSortSpecsBuild(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSortSpecsBuildNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiSortDirection TableGetColumnNextSortDirectionNative(ImGuiTableColumn* column)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumn*, ImGuiSortDirection>)vt[1254])(column);
			#else
			return (ImGuiSortDirection)((delegate* unmanaged[Cdecl]<nint, ImGuiSortDirection>)vt[1254])((nint)column);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumnPtr column)
		{
			ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative(column);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSortDirection TableGetColumnNextSortDirection(ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiSortDirection ret = TableGetColumnNextSortDirectionNative((ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableFixColumnSortDirectionNative(ImGuiTable* table, ImGuiTableColumn* column)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableColumn*, void>)vt[1255])(table, column);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1255])((nint)table, (nint)column);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			TableFixColumnSortDirectionNative(table, column);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableFixColumnSortDirection(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableFixColumnSortDirectionNative((ImGuiTable*)ptable, column);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				TableFixColumnSortDirectionNative(table, (ImGuiTableColumn*)pcolumn);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableFixColumnSortDirection(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					TableFixColumnSortDirectionNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float TableGetColumnWidthAutoNative(ImGuiTable* table, ImGuiTableColumn* column)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableColumn*, float>)vt[1256])(table, column);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, nint, float>)vt[1256])((nint)table, (nint)column);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			float ret = TableGetColumnWidthAutoNative(table, column);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, column);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				float ret = TableGetColumnWidthAutoNative(table, (ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					float ret = TableGetColumnWidthAutoNative((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableBeginRowNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1257])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1257])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginRow(ImGuiTablePtr table)
		{
			TableBeginRowNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginRowNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableEndRowNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1258])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1258])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableEndRow(ImGuiTablePtr table)
		{
			TableEndRowNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableEndRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndRowNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableBeginCellNative(ImGuiTable* table, int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, int, void>)vt[1259])(table, columnN);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[1259])((nint)table, columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginCell(ImGuiTablePtr table, int columnN)
		{
			TableBeginCellNative(table, columnN);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableBeginCell(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableBeginCellNative((ImGuiTable*)ptable, columnN);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableEndCellNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1260])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1260])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableEndCell(ImGuiTablePtr table)
		{
			TableEndCellNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableEndCell(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableEndCellNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableGetCellBgRectNative(ImRect* pOut, ImGuiTable* table, int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiTable*, int, void>)vt[1261])(pOut, table, columnN);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)vt[1261])((nint)pOut, (nint)table, columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect TableGetCellBgRect(ImGuiTablePtr table, int columnN)
		{
			ImRect ret;
			TableGetCellBgRectNative(&ret, table, columnN);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGetCellBgRect(ImRectPtr pOut, ImGuiTablePtr table, int columnN)
		{
			TableGetCellBgRectNative(pOut, table, columnN);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGetCellBgRect(ref ImRect pOut, ImGuiTablePtr table, int columnN)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				TableGetCellBgRectNative((ImRect*)ppOut, table, columnN);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect TableGetCellBgRect(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImRect ret;
				TableGetCellBgRectNative(&ret, (ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGetCellBgRect(ImRectPtr pOut, ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGetCellBgRectNative(pOut, (ImGuiTable*)ptable, columnN);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGetCellBgRect(ref ImRect pOut, ref ImGuiTable table, int columnN)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiTable* ptable = &table)
				{
					TableGetCellBgRectNative((ImRect*)ppOut, (ImGuiTable*)ptable, columnN);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte* TableGetColumnNameTablePtrNative(ImGuiTable* table, int columnN)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, byte*>)vt[1262])(table, columnN);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[1262])((nint)table, columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TableGetColumnNameTablePtr(ImGuiTablePtr table, int columnN)
		{
			byte* ret = TableGetColumnNameTablePtrNative(table, columnN);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TableGetColumnNameTablePtrS(ImGuiTablePtr table, int columnN)
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameTablePtrNative(table, columnN));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TableGetColumnNameTablePtr(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte* ret = TableGetColumnNameTablePtrNative((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TableGetColumnNameTablePtrS(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				string ret = Utils.DecodeStringUTF8(TableGetColumnNameTablePtrNative((ImGuiTable*)ptable, columnN));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static uint TableGetColumnResizeIDNative(ImGuiTable* table, int columnN, int instanceNo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, int, uint>)vt[1263])(table, columnN, instanceNo);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, int, uint>)vt[1263])((nint)table, columnN, instanceNo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TableGetColumnResizeID(ImGuiTablePtr table, int columnN, int instanceNo)
		{
			uint ret = TableGetColumnResizeIDNative(table, columnN, instanceNo);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TableGetColumnResizeID(ref ImGuiTable table, int columnN, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				uint ret = TableGetColumnResizeIDNative((ImGuiTable*)ptable, columnN, instanceNo);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static float TableGetMaxColumnWidthNative(ImGuiTable* table, int columnN)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, int, float>)vt[1264])(table, columnN);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, int, float>)vt[1264])((nint)table, columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetMaxColumnWidth(ImGuiTablePtr table, int columnN)
		{
			float ret = TableGetMaxColumnWidthNative(table, columnN);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TableGetMaxColumnWidth(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = TableGetMaxColumnWidthNative((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSetColumnWidthAutoSingleNative(ImGuiTable* table, int columnN)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, int, void>)vt[1265])(table, columnN);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[1265])((nint)table, columnN);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnWidthAutoSingle(ImGuiTablePtr table, int columnN)
		{
			TableSetColumnWidthAutoSingleNative(table, columnN);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnWidthAutoSingle(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoSingleNative((ImGuiTable*)ptable, columnN);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSetColumnWidthAutoAllNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1266])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1266])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnWidthAutoAll(ImGuiTablePtr table)
		{
			TableSetColumnWidthAutoAllNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSetColumnWidthAutoAll(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSetColumnWidthAutoAllNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableRemoveNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1267])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1267])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableRemove(ImGuiTablePtr table)
		{
			TableRemoveNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableRemove(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableRemoveNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableGcCompactTransientBuffersTablePtrNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1268])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1268])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGcCompactTransientBuffersTablePtr(ImGuiTablePtr table)
		{
			TableGcCompactTransientBuffersTablePtrNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGcCompactTransientBuffersTablePtr(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableGcCompactTransientBuffersTablePtrNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableGcCompactTransientBuffersTableTempDataPtrNative(ImGuiTableTempData* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableTempData*, void>)vt[1269])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1269])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGcCompactTransientBuffersTableTempDataPtr(ImGuiTableTempDataPtr table)
		{
			TableGcCompactTransientBuffersTableTempDataPtrNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGcCompactTransientBuffersTableTempDataPtr(ref ImGuiTableTempData table)
		{
			fixed (ImGuiTableTempData* ptable = &table)
			{
				TableGcCompactTransientBuffersTableTempDataPtrNative((ImGuiTableTempData*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableGcCompactSettingsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1270])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1270])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableGcCompactSettings()
		{
			TableGcCompactSettingsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableLoadSettingsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1271])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1271])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableLoadSettings(ImGuiTablePtr table)
		{
			TableLoadSettingsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableLoadSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableLoadSettingsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSaveSettingsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1272])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1272])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSaveSettings(ImGuiTablePtr table)
		{
			TableSaveSettingsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSaveSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableSaveSettingsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableResetSettingsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)vt[1273])(table);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1273])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableResetSettings(ImGuiTablePtr table)
		{
			TableResetSettingsNative(table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableResetSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				TableResetSettingsNative((ImGuiTable*)ptable);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTableSettings* TableGetBoundSettingsNative(ImGuiTable* table)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*, ImGuiTableSettings*>)vt[1274])(table);
			#else
			return (ImGuiTableSettings*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[1274])((nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableSettingsPtr TableGetBoundSettings(ImGuiTablePtr table)
		{
			ImGuiTableSettingsPtr ret = TableGetBoundSettingsNative(table);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableSettingsPtr TableGetBoundSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableSettingsPtr ret = TableGetBoundSettingsNative((ImGuiTable*)ptable);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TableSettingsAddSettingsHandlerNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[1275])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[1275])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TableSettingsAddSettingsHandler()
		{
			TableSettingsAddSettingsHandlerNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTableSettings* TableSettingsCreateNative(uint id, int columnsCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, ImGuiTableSettings*>)vt[1276])(id, columnsCount);
			#else
			return (ImGuiTableSettings*)((delegate* unmanaged[Cdecl]<uint, int, nint>)vt[1276])(id, columnsCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableSettingsPtr TableSettingsCreate(uint id, int columnsCount)
		{
			ImGuiTableSettingsPtr ret = TableSettingsCreateNative(id, columnsCount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTableSettings* TableSettingsFindByIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiTableSettings*>)vt[1277])(id);
			#else
			return (ImGuiTableSettings*)((delegate* unmanaged[Cdecl]<uint, nint>)vt[1277])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableSettingsPtr TableSettingsFindByID(uint id)
		{
			ImGuiTableSettingsPtr ret = TableSettingsFindByIDNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTabBar* GetCurrentTabBarNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*>)vt[1278])();
			#else
			return (ImGuiTabBar*)((delegate* unmanaged[Cdecl]<nint>)vt[1278])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabBarPtr GetCurrentTabBar()
		{
			ImGuiTabBarPtr ret = GetCurrentTabBarNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginTabBarExNative(ImGuiTabBar* tabBar, ImRect bb, ImGuiTabBarFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImRect, ImGuiTabBarFlags, byte>)vt[1279])(tabBar, bb, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, ImGuiTabBarFlags, byte>)vt[1279])((nint)tabBar, bb, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTabBarEx(ImGuiTabBarPtr tabBar, ImRect bb, ImGuiTabBarFlags flags)
		{
			byte ret = BeginTabBarExNative(tabBar, bb, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = BeginTabBarExNative((ImGuiTabBar*)ptabBar, bb, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTabItem* TabBarFindTabByIDNative(ImGuiTabBar* tabBar, uint tabId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, uint, ImGuiTabItem*>)vt[1280])(tabBar, tabId);
			#else
			return (ImGuiTabItem*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)vt[1280])((nint)tabBar, tabId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarFindTabByID(ImGuiTabBarPtr tabBar, uint tabId)
		{
			ImGuiTabItemPtr ret = TabBarFindTabByIDNative(tabBar, tabId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarFindTabByID(ref ImGuiTabBar tabBar, uint tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindTabByIDNative((ImGuiTabBar*)ptabBar, tabId);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTabItem* TabBarFindTabByOrderNative(ImGuiTabBar* tabBar, int order)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, int, ImGuiTabItem*>)vt[1281])(tabBar, order);
			#else
			return (ImGuiTabItem*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[1281])((nint)tabBar, order);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarFindTabByOrder(ImGuiTabBarPtr tabBar, int order)
		{
			ImGuiTabItemPtr ret = TabBarFindTabByOrderNative(tabBar, order);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarFindTabByOrder(ref ImGuiTabBar tabBar, int order)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindTabByOrderNative((ImGuiTabBar*)ptabBar, order);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTabItem* TabBarFindMostRecentlySelectedTabForActiveWindowNative(ImGuiTabBar* tabBar)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*>)vt[1282])(tabBar);
			#else
			return (ImGuiTabItem*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[1282])((nint)tabBar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBarPtr tabBar)
		{
			ImGuiTabItemPtr ret = TabBarFindMostRecentlySelectedTabForActiveWindowNative(tabBar);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarFindMostRecentlySelectedTabForActiveWindowNative((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiTabItem* TabBarGetCurrentTabNative(ImGuiTabBar* tabBar)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*>)vt[1283])(tabBar);
			#else
			return (ImGuiTabItem*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[1283])((nint)tabBar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarGetCurrentTab(ImGuiTabBarPtr tabBar)
		{
			ImGuiTabItemPtr ret = TabBarGetCurrentTabNative(tabBar);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr TabBarGetCurrentTab(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = TabBarGetCurrentTabNative((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static int TabBarGetTabOrderNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, int>)vt[1284])(tabBar, tab);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[1284])((nint)tabBar, (nint)tab);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TabBarGetTabOrder(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			int ret = TabBarGetTabOrderNative(tabBar, tab);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				int ret = TabBarGetTabOrderNative((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TabBarGetTabOrder(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				int ret = TabBarGetTabOrderNative(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int TabBarGetTabOrder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					int ret = TabBarGetTabOrderNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte* TabBarGetTabNameNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, byte*>)vt[1285])(tabBar, tab);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[1285])((nint)tabBar, (nint)tab);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TabBarGetTabName(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			byte* ret = TabBarGetTabNameNative(tabBar, tab);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TabBarGetTabNameS(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative(tabBar, tab));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* ret = TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, tab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, tab));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TabBarGetTabName(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				byte* ret = TabBarGetTabNameNative(tabBar, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TabBarGetTabNameS(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative(tabBar, (ImGuiTabItem*)ptab));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* TabBarGetTabName(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					byte* ret = TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string TabBarGetTabNameS(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					string ret = Utils.DecodeStringUTF8(TabBarGetTabNameNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabBarAddTabNative(ImGuiTabBar* tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItemFlags, ImGuiWindow*, void>)vt[1286])(tabBar, tabFlags, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiTabItemFlags, nint, void>)vt[1286])((nint)tabBar, tabFlags, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarAddTab(ImGuiTabBarPtr tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindowPtr window)
		{
			TabBarAddTabNative(tabBar, tabFlags, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindowPtr window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarAddTabNative((ImGuiTabBar*)ptabBar, tabFlags, window);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarAddTab(ImGuiTabBarPtr tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabBarAddTabNative(tabBar, tabFlags, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabBarAddTabNative((ImGuiTabBar*)ptabBar, tabFlags, (ImGuiWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabBarRemoveTabNative(ImGuiTabBar* tabBar, uint tabId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, uint, void>)vt[1287])(tabBar, tabId);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)vt[1287])((nint)tabBar, tabId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarRemoveTab(ImGuiTabBarPtr tabBar, uint tabId)
		{
			TabBarRemoveTabNative(tabBar, tabId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarRemoveTab(ref ImGuiTabBar tabBar, uint tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarRemoveTabNative((ImGuiTabBar*)ptabBar, tabId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabBarCloseTabNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, void>)vt[1288])(tabBar, tab);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1288])((nint)tabBar, (nint)tab);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarCloseTab(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			TabBarCloseTabNative(tabBar, tab);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarCloseTabNative((ImGuiTabBar*)ptabBar, tab);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarCloseTab(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarCloseTabNative(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarCloseTabNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabBarQueueFocusNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, void>)vt[1289])(tabBar, tab);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1289])((nint)tabBar, (nint)tab);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueFocus(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			TabBarQueueFocusNative(tabBar, tab);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueFocusNative((ImGuiTabBar*)ptabBar, tab);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueFocus(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueFocusNative(tabBar, (ImGuiTabItem*)ptab);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueFocus(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueFocusNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabBarQueueReorderNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab, int offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, int, void>)vt[1290])(tabBar, tab, offset);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)vt[1290])((nint)tabBar, (nint)tab, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorder(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab, int offset)
		{
			TabBarQueueReorderNative(tabBar, tab, offset);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderNative((ImGuiTabBar*)ptabBar, tab, offset);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorder(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderNative(tabBar, (ImGuiTabItem*)ptab, offset);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, offset);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabBarQueueReorderFromMousePosNative(ImGuiTabBar* tabBar, ImGuiTabItem* tab, Vector2 mousePos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, Vector2, void>)vt[1291])(tabBar, tab, mousePos);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)vt[1291])((nint)tabBar, (nint)tab, mousePos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorderFromMousePos(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab, Vector2 mousePos)
		{
			TabBarQueueReorderFromMousePosNative(tabBar, tab, mousePos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				TabBarQueueReorderFromMousePosNative((ImGuiTabBar*)ptabBar, tab, mousePos);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorderFromMousePos(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				TabBarQueueReorderFromMousePosNative(tabBar, (ImGuiTabItem*)ptab, mousePos);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					TabBarQueueReorderFromMousePosNative((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, mousePos);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte TabBarProcessReorderNative(ImGuiTabBar* tabBar)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, byte>)vt[1292])(tabBar);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[1292])((nint)tabBar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabBarProcessReorder(ImGuiTabBarPtr tabBar)
		{
			byte ret = TabBarProcessReorderNative(tabBar);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabBarProcessReorder(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = TabBarProcessReorderNative((ImGuiTabBar*)ptabBar);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte TabItemExNative(ImGuiTabBar* tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindow* dockedWindow)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, byte*, bool*, ImGuiTabItemFlags, ImGuiWindow*, byte>)vt[1293])(tabBar, label, pOpen, flags, dockedWindow);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, ImGuiTabItemFlags, nint, byte>)vt[1293])((nint)tabBar, (nint)label, (nint)pOpen, flags, (nint)dockedWindow);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte ret = TabItemExNative(tabBar, label, pOpen, flags, dockedWindow);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TabItemExNative(tabBar, pStr0, pOpen, flags, dockedWindow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = TabItemExNative(tabBar, label, (bool*)ppOpen, flags, dockedWindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = TabItemExNative(tabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = TabItemExNative(tabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = TabItemExNative(tabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = TabItemExNative(tabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = TabItemExNative((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabItemCalcSizeNative(Vector2* pOut, byte* label, byte hasCloseButtonOrUnsavedMarker)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, byte, void>)vt[1294])(pOut, label, hasCloseButtonOrUnsavedMarker);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, byte, void>)vt[1294])((nint)pOut, (nint)label, hasCloseButtonOrUnsavedMarker);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 TabItemCalcSize(byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			Vector2 ret;
			TabItemCalcSizeNative(&ret, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(Vector2* pOut, byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			TabItemCalcSizeNative(pOut, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(ref Vector2 pOut, byte* label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				TabItemCalcSizeNative((Vector2*)ppOut, label, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 TabItemCalcSize(ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = &label)
			{
				Vector2 ret;
				TabItemCalcSizeNative(&ret, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 TabItemCalcSize(ReadOnlySpan<byte> label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = label)
			{
				Vector2 ret;
				TabItemCalcSizeNative(&ret, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 TabItemCalcSize(string label, bool hasCloseButtonOrUnsavedMarker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			TabItemCalcSizeNative(&ret, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(ref Vector2 pOut, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* plabel = &label)
				{
					TabItemCalcSizeNative((Vector2*)ppOut, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(ref Vector2 pOut, ReadOnlySpan<byte> label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* plabel = label)
				{
					TabItemCalcSizeNative((Vector2*)ppOut, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(ref Vector2 pOut, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemCalcSizeNative((Vector2*)ppOut, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(Vector2* pOut, ref byte label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = &label)
			{
				TabItemCalcSizeNative(pOut, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(Vector2* pOut, ReadOnlySpan<byte> label, bool hasCloseButtonOrUnsavedMarker)
		{
			fixed (byte* plabel = label)
			{
				TabItemCalcSizeNative(pOut, (byte*)plabel, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSize(Vector2* pOut, string label, bool hasCloseButtonOrUnsavedMarker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemCalcSizeNative(pOut, pStr0, hasCloseButtonOrUnsavedMarker ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabItemCalcSizeWindowPtrNative(Vector2* pOut, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiWindow*, void>)vt[1295])(pOut, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[1295])((nint)pOut, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 TabItemCalcSizeWindowPtr(ImGuiWindowPtr window)
		{
			Vector2 ret;
			TabItemCalcSizeWindowPtrNative(&ret, window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSizeWindowPtr(Vector2* pOut, ImGuiWindowPtr window)
		{
			TabItemCalcSizeWindowPtrNative(pOut, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSizeWindowPtr(ref Vector2 pOut, ImGuiWindowPtr window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				TabItemCalcSizeWindowPtrNative((Vector2*)ppOut, window);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 TabItemCalcSizeWindowPtr(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				TabItemCalcSizeWindowPtrNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSizeWindowPtr(Vector2* pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				TabItemCalcSizeWindowPtrNative(pOut, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemCalcSizeWindowPtr(ref Vector2 pOut, ref ImGuiWindow window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					TabItemCalcSizeWindowPtrNative((Vector2*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabItemBackgroundNative(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawList*, ImRect, ImGuiTabItemFlags, uint, void>)vt[1296])(drawList, bb, flags, col);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, ImGuiTabItemFlags, uint, void>)vt[1296])((nint)drawList, bb, flags, col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemBackground(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			TabItemBackgroundNative(drawList, bb, flags, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemBackground(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemBackgroundNative((ImDrawList*)pdrawList, bb, flags, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void TabItemLabelAndCloseButtonNative(ImDrawList* drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, byte isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawList*, ImRect, ImGuiTabItemFlags, Vector2, byte*, uint, uint, byte, bool*, bool*, void>)vt[1297])(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible, outJustClosed, outTextClipped);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, ImGuiTabItemFlags, Vector2, nint, uint, uint, byte, nint, nint, void>)vt[1297])((nint)drawList, bb, flags, framePadding, (nint)label, tabId, closeButtonId, isContentsVisible, (nint)outJustClosed, (nint)outTextClipped);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					TabItemLabelAndCloseButtonNative(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						TabItemLabelAndCloseButtonNative((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}
	}
}
