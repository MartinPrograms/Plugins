// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		internal static Vector2* ImVec2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*>)vt[0])();
			#else
			return (Vector2*)((delegate* unmanaged[Cdecl]<nint>)vt[0])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2* ImVec2()
		{
			Vector2* ret = ImVec2Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DestroyNative(Vector2* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[1])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[1])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(Vector2* self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				DestroyNative((Vector2*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static Vector2* ImVec2Native(float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, Vector2*>)vt[2])(x, y);
			#else
			return (Vector2*)((delegate* unmanaged[Cdecl]<float, float, nint>)vt[2])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2* ImVec2(float x, float y)
		{
			Vector2* ret = ImVec2Native(x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static Vector4* ImVec4Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4*>)vt[3])();
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<nint>)vt[3])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4* ImVec4()
		{
			Vector4* ret = ImVec4Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void DestroyNative(Vector4* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, void>)vt[4])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[4])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(Vector4* self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				DestroyNative((Vector4*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static Vector4* ImVec4Native(float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, Vector4*>)vt[5])(x, y, z, w);
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<float, float, float, float, nint>)vt[5])(x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4* ImVec4(float x, float y, float z, float w)
		{
			Vector4* ret = ImVec4Native(x, y, z, w);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiContext* CreateContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)vt[6])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[6])((nint)sharedFontAtlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr CreateContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = CreateContextNative(sharedFontAtlas);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr CreateContext()
		{
			ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		/// <summary>
		/// NULL = destroy current context<br/>
		/// </summary>
		internal static void DestroyContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[7])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[7])((nint)ctx);
			#endif
		}

		/// <summary>
		/// NULL = destroy current context<br/>
		/// </summary>
		public static void DestroyContext(ImGuiContextPtr ctx)
		{
			DestroyContextNative(ctx);
		}

		/// <summary>
		/// NULL = destroy current context<br/>
		/// </summary>
		public static void DestroyContext()
		{
			DestroyContextNative((ImGuiContext*)(default));
		}

		/// <summary>
		/// NULL = destroy current context<br/>
		/// </summary>
		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DestroyContextNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static ImGuiContext* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*>)vt[8])();
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint>)vt[8])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void SetCurrentContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)vt[9])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[9])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ImGuiContextPtr ctx)
		{
			SetCurrentContextNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// access the IO structure (mousekeyboardgamepad inputs, time, various configuration optionsflags)<br/>
		/// </summary>
		internal static ImGuiIO* GetIONative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIO*>)vt[10])();
			#else
			return (ImGuiIO*)((delegate* unmanaged[Cdecl]<nint>)vt[10])();
			#endif
		}

		/// <summary>
		/// access the IO structure (mousekeyboardgamepad inputs, time, various configuration optionsflags)<br/>
		/// </summary>
		public static ImGuiIOPtr GetIO()
		{
			ImGuiIOPtr ret = GetIONative();
			return ret;
		}

		/// <summary>
		/// access the Style structure (colors, sizes). Always use PushStyleColor(), PushStyleVar() to modify style mid-frame!<br/>
		/// </summary>
		internal static ImGuiStyle* GetStyleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyle*>)vt[11])();
			#else
			return (ImGuiStyle*)((delegate* unmanaged[Cdecl]<nint>)vt[11])();
			#endif
		}

		/// <summary>
		/// access the Style structure (colors, sizes). Always use PushStyleColor(), PushStyleVar() to modify style mid-frame!<br/>
		/// </summary>
		public static ImGuiStylePtr GetStyle()
		{
			ImGuiStylePtr ret = GetStyleNative();
			return ret;
		}

		/// <summary>
		/// start a new Dear ImGui frame, you can submit any command from this point until Render()EndFrame().<br/>
		/// </summary>
		internal static void NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[12])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[12])();
			#endif
		}

		/// <summary>
		/// start a new Dear ImGui frame, you can submit any command from this point until Render()EndFrame().<br/>
		/// </summary>
		public static void NewFrame()
		{
			NewFrameNative();
		}

		/// <summary>
		/// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!<br/>
		/// </summary>
		internal static void EndFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[13])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[13])();
			#endif
		}

		/// <summary>
		/// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!<br/>
		/// </summary>
		public static void EndFrame()
		{
			EndFrameNative();
		}

		/// <summary>
		/// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().<br/>
		/// </summary>
		internal static void RenderNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[14])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[14])();
			#endif
		}

		/// <summary>
		/// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().<br/>
		/// </summary>
		public static void Render()
		{
			RenderNative();
		}

		/// <summary>
		/// valid after Render() and until the next call to NewFrame(). this is what you have to render.<br/>
		/// </summary>
		internal static ImDrawData* GetDrawDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawData*>)vt[15])();
			#else
			return (ImDrawData*)((delegate* unmanaged[Cdecl]<nint>)vt[15])();
			#endif
		}

		/// <summary>
		/// valid after Render() and until the next call to NewFrame(). this is what you have to render.<br/>
		/// </summary>
		public static ImDrawDataPtr GetDrawData()
		{
			ImDrawDataPtr ret = GetDrawDataNative();
			return ret;
		}

		/// <summary>
		/// create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!<br/>
		/// </summary>
		internal static void ShowDemoWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[16])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[16])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!<br/>
		/// </summary>
		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		/// <summary>
		/// create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!<br/>
		/// </summary>
		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		/// <summary>
		/// create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!<br/>
		/// </summary>
		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// create MetricsDebugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.<br/>
		/// </summary>
		internal static void ShowMetricsWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[17])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[17])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// create MetricsDebugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.<br/>
		/// </summary>
		public static void ShowMetricsWindow(bool* pOpen)
		{
			ShowMetricsWindowNative(pOpen);
		}

		/// <summary>
		/// create MetricsDebugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.<br/>
		/// </summary>
		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		/// <summary>
		/// create MetricsDebugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.<br/>
		/// </summary>
		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowMetricsWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// create Debug Log window. display a simplified log of important dear imgui events.<br/>
		/// </summary>
		internal static void ShowDebugLogWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[18])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[18])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// create Debug Log window. display a simplified log of important dear imgui events.<br/>
		/// </summary>
		public static void ShowDebugLogWindow(bool* pOpen)
		{
			ShowDebugLogWindowNative(pOpen);
		}

		/// <summary>
		/// create Debug Log window. display a simplified log of important dear imgui events.<br/>
		/// </summary>
		public static void ShowDebugLogWindow()
		{
			ShowDebugLogWindowNative((bool*)(default));
		}

		/// <summary>
		/// create Debug Log window. display a simplified log of important dear imgui events.<br/>
		/// </summary>
		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDebugLogWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.<br/>
		/// </summary>
		internal static void ShowIDStackToolWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[19])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[19])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.<br/>
		/// </summary>
		public static void ShowIDStackToolWindow(bool* pOpen)
		{
			ShowIDStackToolWindowNative(pOpen);
		}

		/// <summary>
		/// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.<br/>
		/// </summary>
		public static void ShowIDStackToolWindow()
		{
			ShowIDStackToolWindowNative((bool*)(default));
		}

		/// <summary>
		/// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.<br/>
		/// </summary>
		public static void ShowIDStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowIDStackToolWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// create About window. display Dear ImGui version, credits and buildsystem information.<br/>
		/// </summary>
		internal static void ShowAboutWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)vt[20])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[20])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// create About window. display Dear ImGui version, credits and buildsystem information.<br/>
		/// </summary>
		public static void ShowAboutWindow(bool* pOpen)
		{
			ShowAboutWindowNative(pOpen);
		}

		/// <summary>
		/// create About window. display Dear ImGui version, credits and buildsystem information.<br/>
		/// </summary>
		public static void ShowAboutWindow()
		{
			ShowAboutWindowNative((bool*)(default));
		}

		/// <summary>
		/// create About window. display Dear ImGui version, credits and buildsystem information.<br/>
		/// </summary>
		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowAboutWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)<br/>
		/// </summary>
		internal static void ShowStyleEditorNative(ImGuiStyle* reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[21])(reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[21])((nint)reference);
			#endif
		}

		/// <summary>
		/// add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)<br/>
		/// </summary>
		public static void ShowStyleEditor(ImGuiStylePtr reference)
		{
			ShowStyleEditorNative(reference);
		}

		/// <summary>
		/// add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)<br/>
		/// </summary>
		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)<br/>
		/// </summary>
		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImGuiStyle*)preference);
			}
		}

		/// <summary>
		/// add style selector block (not a window), essentially a combo listing the default styles.<br/>
		/// </summary>
		internal static byte ShowStyleSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)vt[22])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[22])((nint)label);
			#endif
		}

		/// <summary>
		/// add style selector block (not a window), essentially a combo listing the default styles.<br/>
		/// </summary>
		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// add style selector block (not a window), essentially a combo listing the default styles.<br/>
		/// </summary>
		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// add style selector block (not a window), essentially a combo listing the default styles.<br/>
		/// </summary>
		public static bool ShowStyleSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// add style selector block (not a window), essentially a combo listing the default styles.<br/>
		/// </summary>
		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// add font selector block (not a window), essentially a combo listing the loaded fonts.<br/>
		/// </summary>
		internal static void ShowFontSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[23])(label);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[23])((nint)label);
			#endif
		}

		/// <summary>
		/// add font selector block (not a window), essentially a combo listing the loaded fonts.<br/>
		/// </summary>
		public static void ShowFontSelector(byte* label)
		{
			ShowFontSelectorNative(label);
		}

		/// <summary>
		/// add font selector block (not a window), essentially a combo listing the loaded fonts.<br/>
		/// </summary>
		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		/// <summary>
		/// add font selector block (not a window), essentially a combo listing the loaded fonts.<br/>
		/// </summary>
		public static void ShowFontSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		/// <summary>
		/// add font selector block (not a window), essentially a combo listing the loaded fonts.<br/>
		/// </summary>
		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowFontSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// add basic helpinfo block (not a window): how to manipulate ImGui as an end-user (mousekeyboard controls).<br/>
		/// </summary>
		internal static void ShowUserGuideNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[24])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[24])();
			#endif
		}

		/// <summary>
		/// add basic helpinfo block (not a window): how to manipulate ImGui as an end-user (mousekeyboard controls).<br/>
		/// </summary>
		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		/// <summary>
		/// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)<br/>
		/// </summary>
		internal static byte* GetVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)vt[25])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)vt[25])();
			#endif
		}

		/// <summary>
		/// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)<br/>
		/// </summary>
		public static byte* GetVersion()
		{
			byte* ret = GetVersionNative();
			return ret;
		}

		/// <summary>
		/// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)<br/>
		/// </summary>
		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(GetVersionNative());
			return ret;
		}

		/// <summary>
		/// new, recommended style (default)<br/>
		/// </summary>
		internal static void StyleColorsDarkNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[26])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[26])((nint)dst);
			#endif
		}

		/// <summary>
		/// new, recommended style (default)<br/>
		/// </summary>
		public static void StyleColorsDark(ImGuiStylePtr dst)
		{
			StyleColorsDarkNative(dst);
		}

		/// <summary>
		/// new, recommended style (default)<br/>
		/// </summary>
		public static void StyleColorsDark()
		{
			StyleColorsDarkNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// new, recommended style (default)<br/>
		/// </summary>
		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsDarkNative((ImGuiStyle*)pdst);
			}
		}

		/// <summary>
		/// best used with borders and a custom, thicker font<br/>
		/// </summary>
		internal static void StyleColorsLightNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[27])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[27])((nint)dst);
			#endif
		}

		/// <summary>
		/// best used with borders and a custom, thicker font<br/>
		/// </summary>
		public static void StyleColorsLight(ImGuiStylePtr dst)
		{
			StyleColorsLightNative(dst);
		}

		/// <summary>
		/// best used with borders and a custom, thicker font<br/>
		/// </summary>
		public static void StyleColorsLight()
		{
			StyleColorsLightNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// best used with borders and a custom, thicker font<br/>
		/// </summary>
		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsLightNative((ImGuiStyle*)pdst);
			}
		}

		/// <summary>
		/// classic imgui style<br/>
		/// </summary>
		internal static void StyleColorsClassicNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)vt[28])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[28])((nint)dst);
			#endif
		}

		/// <summary>
		/// classic imgui style<br/>
		/// </summary>
		public static void StyleColorsClassic(ImGuiStylePtr dst)
		{
			StyleColorsClassicNative(dst);
		}

		/// <summary>
		/// classic imgui style<br/>
		/// </summary>
		public static void StyleColorsClassic()
		{
			StyleColorsClassicNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// classic imgui style<br/>
		/// </summary>
		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsClassicNative((ImGuiStyle*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginNative(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, bool*, ImGuiWindowFlags, byte>)vt[29])(name, pOpen, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiWindowFlags, byte>)vt[29])((nint)name, (nint)pOpen, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, pOpen, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, bool* pOpen)
		{
			byte ret = BeginNative(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name)
		{
			byte ret = BeginNative(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, (bool*)(default), flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void EndNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[30])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[30])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void End()
		{
			EndNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginChildNative(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[31])(strId, size, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[31])((nint)strId, size, childFlags, windowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte BeginChildNative(uint id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[32])(id, size, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)vt[32])(id, size, childFlags, windowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void EndChildNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[33])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[33])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndChild()
		{
			EndChildNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsWindowAppearingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[34])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[34])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowAppearing()
		{
			byte ret = IsWindowAppearingNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static byte IsWindowCollapsedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[35])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[35])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowCollapsed()
		{
			byte ret = IsWindowCollapsedNative();
			return ret != 0;
		}

		/// <summary>
		/// is current window focused? or its rootchild, depending on flags. see flags for options.<br/>
		/// </summary>
		internal static byte IsWindowFocusedNative(ImGuiFocusedFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiFocusedFlags, byte>)vt[36])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiFocusedFlags, byte>)vt[36])(flags);
			#endif
		}

		/// <summary>
		/// is current window focused? or its rootchild, depending on flags. see flags for options.<br/>
		/// </summary>
		public static bool IsWindowFocused(ImGuiFocusedFlags flags)
		{
			byte ret = IsWindowFocusedNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// is current window focused? or its rootchild, depending on flags. see flags for options.<br/>
		/// </summary>
		public static bool IsWindowFocused()
		{
			byte ret = IsWindowFocusedNative((ImGuiFocusedFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// is current window hovered and hoverable (e.g. not blocked by a popupmodal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mousekeyboard to Dear ImGui or my application?" for details.<br/>
		/// </summary>
		internal static byte IsWindowHoveredNative(ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[37])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[37])(flags);
			#endif
		}

		/// <summary>
		/// is current window hovered and hoverable (e.g. not blocked by a popupmodal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mousekeyboard to Dear ImGui or my application?" for details.<br/>
		/// </summary>
		public static bool IsWindowHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowHoveredNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// is current window hovered and hoverable (e.g. not blocked by a popupmodal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mousekeyboard to Dear ImGui or my application?" for details.<br/>
		/// </summary>
		public static bool IsWindowHovered()
		{
			byte ret = IsWindowHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// get draw list associated to the current window, to append your own drawing primitives<br/>
		/// </summary>
		internal static ImDrawList* GetWindowDrawListNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawList*>)vt[38])();
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint>)vt[38])();
			#endif
		}

		/// <summary>
		/// get draw list associated to the current window, to append your own drawing primitives<br/>
		/// </summary>
		public static ImDrawListPtr GetWindowDrawList()
		{
			ImDrawListPtr ret = GetWindowDrawListNative();
			return ret;
		}

		/// <summary>
		/// get DPI scale currently associated to the current window's viewport.<br/>
		/// </summary>
		internal static float GetWindowDpiScaleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[39])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[39])();
			#endif
		}

		/// <summary>
		/// get DPI scale currently associated to the current window's viewport.<br/>
		/// </summary>
		public static float GetWindowDpiScale()
		{
			float ret = GetWindowDpiScaleNative();
			return ret;
		}

		/// <summary>
		/// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		internal static void GetWindowPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[40])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[40])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		public static Vector2 GetWindowPos()
		{
			Vector2 ret;
			GetWindowPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		public static void GetWindowPos(Vector2* pOut)
		{
			GetWindowPosNative(pOut);
		}

		/// <summary>
		/// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		public static void GetWindowPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetWindowPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		internal static void GetWindowSizeNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[41])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[41])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		public static Vector2 GetWindowSize()
		{
			Vector2 ret;
			GetWindowSizeNative(&ret);
			return ret;
		}

		/// <summary>
		/// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		public static void GetWindowSize(Vector2* pOut)
		{
			GetWindowSizeNative(pOut);
		}

		/// <summary>
		/// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)<br/>
		/// </summary>
		public static void GetWindowSize(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetWindowSizeNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.<br/>
		/// </summary>
		internal static float GetWindowWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[42])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[42])();
			#endif
		}

		/// <summary>
		/// get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.<br/>
		/// </summary>
		public static float GetWindowWidth()
		{
			float ret = GetWindowWidthNative();
			return ret;
		}

		/// <summary>
		/// get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.<br/>
		/// </summary>
		internal static float GetWindowHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[43])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[43])();
			#endif
		}

		/// <summary>
		/// get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.<br/>
		/// </summary>
		public static float GetWindowHeight()
		{
			float ret = GetWindowHeightNative();
			return ret;
		}

		/// <summary>
		/// get viewport currently associated to the current window.<br/>
		/// </summary>
		internal static ImGuiViewport* GetWindowViewportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*>)vt[44])();
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<nint>)vt[44])();
			#endif
		}

		/// <summary>
		/// get viewport currently associated to the current window.<br/>
		/// </summary>
		public static ImGuiViewportPtr GetWindowViewport()
		{
			ImGuiViewportPtr ret = GetWindowViewportNative();
			return ret;
		}

		/// <summary>
		/// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.<br/>
		/// </summary>
		internal static void SetNextWindowPosNative(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, Vector2, void>)vt[45])(pos, cond, pivot);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, Vector2, void>)vt[45])(pos, cond, pivot);
			#endif
		}

		/// <summary>
		/// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.<br/>
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, cond, pivot);
		}

		/// <summary>
		/// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.<br/>
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetNextWindowPosNative(pos, cond, (Vector2)(new Vector2(0,0)));
		}

		/// <summary>
		/// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.<br/>
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), (Vector2)(new Vector2(0,0)));
		}

		/// <summary>
		/// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.<br/>
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), pivot);
		}

		/// <summary>
		/// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()<br/>
		/// </summary>
		internal static void SetNextWindowSizeNative(Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[46])(size, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[46])(size, cond);
			#endif
		}

		/// <summary>
		/// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()<br/>
		/// </summary>
		public static void SetNextWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetNextWindowSizeNative(size, cond);
		}

		/// <summary>
		/// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()<br/>
		/// </summary>
		public static void SetNextWindowSize(Vector2 size)
		{
			SetNextWindowSizeNative(size, (ImGuiCond)(0));
		}

		/// <summary>
		/// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.<br/>
		/// </summary>
		internal static void SetNextWindowSizeConstraintsNative(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, delegate*<ImGuiSizeCallbackData*, void>, void*, void>)vt[47])(sizeMin, sizeMax, (delegate*<ImGuiSizeCallbackData*, void>)Utils.GetFunctionPointerForDelegate(customCallback), customCallbackData);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, nint, nint, void>)vt[47])(sizeMin, sizeMax, (nint)Utils.GetFunctionPointerForDelegate(customCallback), (nint)customCallbackData);
			#endif
		}

		/// <summary>
		/// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.<br/>
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, customCallbackData);
		}

		/// <summary>
		/// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.<br/>
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, (void*)(default));
		}

		/// <summary>
		/// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.<br/>
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}

		/// <summary>
		/// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.<br/>
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), customCallbackData);
		}

		/// <summary>
		/// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()<br/>
		/// </summary>
		internal static void SetNextWindowContentSizeNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[48])(size);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[48])(size);
			#endif
		}

		/// <summary>
		/// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()<br/>
		/// </summary>
		public static void SetNextWindowContentSize(Vector2 size)
		{
			SetNextWindowContentSizeNative(size);
		}

		/// <summary>
		/// set next window collapsed state. call before Begin()<br/>
		/// </summary>
		internal static void SetNextWindowCollapsedNative(byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[49])(collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[49])(collapsed, cond);
			#endif
		}

		/// <summary>
		/// set next window collapsed state. call before Begin()<br/>
		/// </summary>
		public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// set next window collapsed state. call before Begin()<br/>
		/// </summary>
		public static void SetNextWindowCollapsed(bool collapsed)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// set next window to be focused  top-most. call before Begin()<br/>
		/// </summary>
		internal static void SetNextWindowFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[50])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[50])();
			#endif
		}

		/// <summary>
		/// set next window to be focused  top-most. call before Begin()<br/>
		/// </summary>
		public static void SetNextWindowFocus()
		{
			SetNextWindowFocusNative();
		}

		/// <summary>
		/// set next window scrolling value (use &lt; 0.0f to not affect a given axis).<br/>
		/// </summary>
		internal static void SetNextWindowScrollNative(Vector2 scroll)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[51])(scroll);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[51])(scroll);
			#endif
		}

		/// <summary>
		/// set next window scrolling value (use &lt; 0.0f to not affect a given axis).<br/>
		/// </summary>
		public static void SetNextWindowScroll(Vector2 scroll)
		{
			SetNextWindowScrollNative(scroll);
		}

		/// <summary>
		/// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBgChildBgPopupBg. you may also use ImGuiWindowFlags_NoBackground.<br/>
		/// </summary>
		internal static void SetNextWindowBgAlphaNative(float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[52])(alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[52])(alpha);
			#endif
		}

		/// <summary>
		/// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBgChildBgPopupBg. you may also use ImGuiWindowFlags_NoBackground.<br/>
		/// </summary>
		public static void SetNextWindowBgAlpha(float alpha)
		{
			SetNextWindowBgAlphaNative(alpha);
		}

		/// <summary>
		/// set next window viewport<br/>
		/// </summary>
		internal static void SetNextWindowViewportNative(uint viewportId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)vt[53])(viewportId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)vt[53])(viewportId);
			#endif
		}

		/// <summary>
		/// set next window viewport<br/>
		/// </summary>
		public static void SetNextWindowViewport(uint viewportId)
		{
			SetNextWindowViewportNative(viewportId);
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		internal static void SetWindowPosNative(Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[54])(pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[54])(pos, cond);
			#endif
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		public static void SetWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(pos, cond);
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		public static void SetWindowPos(Vector2 pos)
		{
			SetWindowPosNative(pos, (ImGuiCond)(0));
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		internal static void SetWindowSizeNative(Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[55])(size, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)vt[55])(size, cond);
			#endif
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		public static void SetWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(size, cond);
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		public static void SetWindowSize(Vector2 size)
		{
			SetWindowSizeNative(size, (ImGuiCond)(0));
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		internal static void SetWindowCollapsedNative(byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[56])(collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[56])(collapsed, cond);
			#endif
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		public static void SetWindowCollapsed(bool collapsed)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// (not recommended) set current window to be focused  top-most. prefer using SetNextWindowFocus().<br/>
		/// </summary>
		internal static void SetWindowFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[57])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[57])();
			#endif
		}

		/// <summary>
		/// (not recommended) set current window to be focused  top-most. prefer using SetNextWindowFocus().<br/>
		/// </summary>
		public static void SetWindowFocus()
		{
			SetWindowFocusNative();
		}

		/// <summary>
		/// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().<br/>
		/// </summary>
		internal static void SetWindowFontScaleNative(float scale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[58])(scale);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[58])(scale);
			#endif
		}

		/// <summary>
		/// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().<br/>
		/// </summary>
		public static void SetWindowFontScale(float scale)
		{
			SetWindowFontScaleNative(scale);
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		internal static void SetWindowPosNative(byte* name, Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiCond, void>)vt[59])(name, pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)vt[59])((nint)name, pos, cond);
			#endif
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(name, pos, cond);
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(byte* name, Vector2 pos)
		{
			SetWindowPosNative(name, pos, (ImGuiCond)(0));
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos)
		{
			fixed (byte* pname = name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// set named window position.<br/>
		/// </summary>
		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		internal static void SetWindowSizeNative(byte* name, Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiCond, void>)vt[60])(name, size, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)vt[60])((nint)name, size, cond);
			#endif
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(name, size, cond);
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(byte* name, Vector2 size)
		{
			SetWindowSizeNative(name, size, (ImGuiCond)(0));
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size)
		{
			fixed (byte* pname = name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// set named window size. set axis to 0.0f to force an auto-fit on this axis.<br/>
		/// </summary>
		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		internal static void SetWindowCollapsedNative(byte* name, byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte, ImGuiCond, void>)vt[61])(name, collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, ImGuiCond, void>)vt[61])((nint)name, collapsed, cond);
			#endif
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(byte* name, bool collapsed)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed)
		{
			fixed (byte* pname = name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// set named window collapsed state<br/>
		/// </summary>
		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// (not recommended) set current window to be focused  top-most. prefer using SetNextWindowFocus().<br/>
		/// </summary>
		internal static void SetWindowFocusNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[62])(name);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[62])((nint)name);
			#endif
		}

		/// <summary>
		/// set named window to be focused  top-most. use NULL to remove focus.<br/>
		/// </summary>
		public static void SetWindowFocus(byte* name)
		{
			SetWindowFocusNative(name);
		}

		/// <summary>
		/// set named window to be focused  top-most. use NULL to remove focus.<br/>
		/// </summary>
		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		/// <summary>
		/// set named window to be focused  top-most. use NULL to remove focus.<br/>
		/// </summary>
		public static void SetWindowFocus(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		/// <summary>
		/// set named window to be focused  top-most. use NULL to remove focus.<br/>
		/// </summary>
		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowFocusNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// get scrolling amount [0 .. GetScrollMaxX()]<br/>
		/// </summary>
		internal static float GetScrollXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[63])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[63])();
			#endif
		}

		/// <summary>
		/// get scrolling amount [0 .. GetScrollMaxX()]<br/>
		/// </summary>
		public static float GetScrollX()
		{
			float ret = GetScrollXNative();
			return ret;
		}

		/// <summary>
		/// get scrolling amount [0 .. GetScrollMaxY()]<br/>
		/// </summary>
		internal static float GetScrollYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[64])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[64])();
			#endif
		}

		/// <summary>
		/// get scrolling amount [0 .. GetScrollMaxY()]<br/>
		/// </summary>
		public static float GetScrollY()
		{
			float ret = GetScrollYNative();
			return ret;
		}

		/// <summary>
		/// set scrolling amount [0 .. GetScrollMaxX()]<br/>
		/// </summary>
		internal static void SetScrollXNative(float scrollX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[65])(scrollX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[65])(scrollX);
			#endif
		}

		/// <summary>
		/// set scrolling amount [0 .. GetScrollMaxX()]<br/>
		/// </summary>
		public static void SetScrollX(float scrollX)
		{
			SetScrollXNative(scrollX);
		}

		/// <summary>
		/// set scrolling amount [0 .. GetScrollMaxY()]<br/>
		/// </summary>
		internal static void SetScrollYNative(float scrollY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[66])(scrollY);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[66])(scrollY);
			#endif
		}

		/// <summary>
		/// set scrolling amount [0 .. GetScrollMaxY()]<br/>
		/// </summary>
		public static void SetScrollY(float scrollY)
		{
			SetScrollYNative(scrollY);
		}

		/// <summary>
		/// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x<br/>
		/// </summary>
		internal static float GetScrollMaxXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[67])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[67])();
			#endif
		}

		/// <summary>
		/// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x<br/>
		/// </summary>
		public static float GetScrollMaxX()
		{
			float ret = GetScrollMaxXNative();
			return ret;
		}

		/// <summary>
		/// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y<br/>
		/// </summary>
		internal static float GetScrollMaxYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[68])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[68])();
			#endif
		}

		/// <summary>
		/// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y<br/>
		/// </summary>
		public static float GetScrollMaxY()
		{
			float ret = GetScrollMaxYNative();
			return ret;
		}

		/// <summary>
		/// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "defaultcurrent item" visible, consider using SetItemDefaultFocus() instead.<br/>
		/// </summary>
		internal static void SetScrollHereXNative(float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[69])(centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[69])(centerXRatio);
			#endif
		}

		/// <summary>
		/// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "defaultcurrent item" visible, consider using SetItemDefaultFocus() instead.<br/>
		/// </summary>
		public static void SetScrollHereX(float centerXRatio)
		{
			SetScrollHereXNative(centerXRatio);
		}

		/// <summary>
		/// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "defaultcurrent item" visible, consider using SetItemDefaultFocus() instead.<br/>
		/// </summary>
		public static void SetScrollHereX()
		{
			SetScrollHereXNative((float)(0.5f));
		}

		/// <summary>
		/// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "defaultcurrent item" visible, consider using SetItemDefaultFocus() instead.<br/>
		/// </summary>
		internal static void SetScrollHereYNative(float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[70])(centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[70])(centerYRatio);
			#endif
		}

		/// <summary>
		/// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "defaultcurrent item" visible, consider using SetItemDefaultFocus() instead.<br/>
		/// </summary>
		public static void SetScrollHereY(float centerYRatio)
		{
			SetScrollHereYNative(centerYRatio);
		}

		/// <summary>
		/// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "defaultcurrent item" visible, consider using SetItemDefaultFocus() instead.<br/>
		/// </summary>
		public static void SetScrollHereY()
		{
			SetScrollHereYNative((float)(0.5f));
		}

		/// <summary>
		/// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.<br/>
		/// </summary>
		internal static void SetScrollFromPosXNative(float localX, float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[71])(localX, centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[71])(localX, centerXRatio);
			#endif
		}

		/// <summary>
		/// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.<br/>
		/// </summary>
		public static void SetScrollFromPosX(float localX, float centerXRatio)
		{
			SetScrollFromPosXNative(localX, centerXRatio);
		}

		/// <summary>
		/// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.<br/>
		/// </summary>
		public static void SetScrollFromPosX(float localX)
		{
			SetScrollFromPosXNative(localX, (float)(0.5f));
		}

		/// <summary>
		/// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.<br/>
		/// </summary>
		internal static void SetScrollFromPosYNative(float localY, float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[72])(localY, centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[72])(localY, centerYRatio);
			#endif
		}

		/// <summary>
		/// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.<br/>
		/// </summary>
		public static void SetScrollFromPosY(float localY, float centerYRatio)
		{
			SetScrollFromPosYNative(localY, centerYRatio);
		}

		/// <summary>
		/// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.<br/>
		/// </summary>
		public static void SetScrollFromPosY(float localY)
		{
			SetScrollFromPosYNative(localY, (float)(0.5f));
		}

		/// <summary>
		/// use NULL as a shortcut to push default font<br/>
		/// </summary>
		internal static void PushFontNative(ImFont* font)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImFont*, void>)vt[73])(font);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[73])((nint)font);
			#endif
		}

		/// <summary>
		/// use NULL as a shortcut to push default font<br/>
		/// </summary>
		public static void PushFont(ImFontPtr font)
		{
			PushFontNative(font);
		}

		/// <summary>
		/// use NULL as a shortcut to push default font<br/>
		/// </summary>
		public static void PushFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				PushFontNative((ImFont*)pfont);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopFontNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[74])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[74])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopFont()
		{
			PopFontNative();
		}

		/// <summary>
		/// modify a style color. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		internal static void PushStyleColorNative(ImGuiCol idx, uint col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, uint, void>)vt[75])(idx, col);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, uint, void>)vt[75])(idx, col);
			#endif
		}

		/// <summary>
		/// modify a style color. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		public static void PushStyleColor(ImGuiCol idx, uint col)
		{
			PushStyleColorNative(idx, col);
		}

		/// <summary>
		/// modify a style color. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		internal static void PushStyleColorNative(ImGuiCol idx, Vector4 col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4, void>)vt[76])(idx, col);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4, void>)vt[76])(idx, col);
			#endif
		}

		/// <summary>
		/// modify a style color. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		public static void PushStyleColor(ImGuiCol idx, Vector4 col)
		{
			PushStyleColorNative(idx, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopStyleColorNative(int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[77])(count);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[77])(count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleColor(int count)
		{
			PopStyleColorNative(count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleColor()
		{
			PopStyleColorNative((int)(1));
		}

		/// <summary>
		/// modify a style float variable. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		internal static void PushStyleVarNative(ImGuiStyleVar idx, float val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)vt[78])(idx, val);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)vt[78])(idx, val);
			#endif
		}

		/// <summary>
		/// modify a style float variable. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		public static void PushStyleVar(ImGuiStyleVar idx, float val)
		{
			PushStyleVarNative(idx, val);
		}

		/// <summary>
		/// modify a style float variable. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		internal static void PushStyleVarNative(ImGuiStyleVar idx, Vector2 val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, void>)vt[79])(idx, val);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, void>)vt[79])(idx, val);
			#endif
		}

		/// <summary>
		/// modify a style ImVec2 variable. always use this if you modify the style after NewFrame().<br/>
		/// </summary>
		public static void PushStyleVar(ImGuiStyleVar idx, Vector2 val)
		{
			PushStyleVarNative(idx, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopStyleVarNative(int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[80])(count);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[80])(count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleVar(int count)
		{
			PopStyleVarNative(count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleVar()
		{
			PopStyleVarNative((int)(1));
		}

		/// <summary>
		/// modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)<br/>
		/// </summary>
		internal static void PushItemFlagNative(ImGuiItemFlags option, byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiItemFlags, byte, void>)vt[81])(option, enabled);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiItemFlags, byte, void>)vt[81])(option, enabled);
			#endif
		}

		/// <summary>
		/// modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)<br/>
		/// </summary>
		public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
		{
			PushItemFlagNative(option, enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopItemFlagNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[82])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[82])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopItemFlag()
		{
			PopItemFlagNative();
		}

		/// <summary>
		/// push width of items for common large "item+label" widgets. &gt;0.0f: width in pixels, &lt;0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).<br/>
		/// </summary>
		internal static void PushItemWidthNative(float itemWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[83])(itemWidth);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[83])(itemWidth);
			#endif
		}

		/// <summary>
		/// push width of items for common large "item+label" widgets. &gt;0.0f: width in pixels, &lt;0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).<br/>
		/// </summary>
		public static void PushItemWidth(float itemWidth)
		{
			PushItemWidthNative(itemWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopItemWidthNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[84])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[84])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopItemWidth()
		{
			PopItemWidthNative();
		}

		/// <summary>
		/// set width of the _next_ common large "item+label" widget. &gt;0.0f: width in pixels, &lt;0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)<br/>
		/// </summary>
		internal static void SetNextItemWidthNative(float itemWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[85])(itemWidth);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[85])(itemWidth);
			#endif
		}

		/// <summary>
		/// set width of the _next_ common large "item+label" widget. &gt;0.0f: width in pixels, &lt;0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)<br/>
		/// </summary>
		public static void SetNextItemWidth(float itemWidth)
		{
			SetNextItemWidthNative(itemWidth);
		}

		/// <summary>
		/// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.<br/>
		/// </summary>
		internal static float CalcItemWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[86])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[86])();
			#endif
		}

		/// <summary>
		/// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.<br/>
		/// </summary>
		public static float CalcItemWidth()
		{
			float ret = CalcItemWidthNative();
			return ret;
		}

		/// <summary>
		/// push word-wrapping position for Text*() commands. &lt; 0.0f: no wrapping; 0.0f: wrap to end of window (or column); &gt; 0.0f: wrap at 'wrap_pos_x' position in window local space<br/>
		/// </summary>
		internal static void PushTextWrapPosNative(float wrapLocalPosX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[87])(wrapLocalPosX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[87])(wrapLocalPosX);
			#endif
		}

		/// <summary>
		/// push word-wrapping position for Text*() commands. &lt; 0.0f: no wrapping; 0.0f: wrap to end of window (or column); &gt; 0.0f: wrap at 'wrap_pos_x' position in window local space<br/>
		/// </summary>
		public static void PushTextWrapPos(float wrapLocalPosX)
		{
			PushTextWrapPosNative(wrapLocalPosX);
		}

		/// <summary>
		/// push word-wrapping position for Text*() commands. &lt; 0.0f: no wrapping; 0.0f: wrap to end of window (or column); &gt; 0.0f: wrap at 'wrap_pos_x' position in window local space<br/>
		/// </summary>
		public static void PushTextWrapPos()
		{
			PushTextWrapPosNative((float)(0.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		internal static void PopTextWrapPosNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[88])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[88])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopTextWrapPos()
		{
			PopTextWrapPosNative();
		}

		/// <summary>
		/// get current font<br/>
		/// </summary>
		internal static ImFont* GetFontNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFont*>)vt[89])();
			#else
			return (ImFont*)((delegate* unmanaged[Cdecl]<nint>)vt[89])();
			#endif
		}

		/// <summary>
		/// get current font<br/>
		/// </summary>
		public static ImFontPtr GetFont()
		{
			ImFontPtr ret = GetFontNative();
			return ret;
		}

		/// <summary>
		/// get current font size (= height in pixels) of current font with current scale applied<br/>
		/// </summary>
		internal static float GetFontSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[90])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[90])();
			#endif
		}

		/// <summary>
		/// get current font size (= height in pixels) of current font with current scale applied<br/>
		/// </summary>
		public static float GetFontSize()
		{
			float ret = GetFontSizeNative();
			return ret;
		}

		/// <summary>
		/// get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API<br/>
		/// </summary>
		internal static void GetFontTexUvWhitePixelNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[91])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[91])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API<br/>
		/// </summary>
		public static Vector2 GetFontTexUvWhitePixel()
		{
			Vector2 ret;
			GetFontTexUvWhitePixelNative(&ret);
			return ret;
		}

		/// <summary>
		/// get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API<br/>
		/// </summary>
		public static void GetFontTexUvWhitePixel(Vector2* pOut)
		{
			GetFontTexUvWhitePixelNative(pOut);
		}

		/// <summary>
		/// get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API<br/>
		/// </summary>
		public static void GetFontTexUvWhitePixel(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetFontTexUvWhitePixelNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		internal static uint GetColorU32Native(ImGuiCol idx, float alphaMul)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, float, uint>)vt[92])(idx, alphaMul);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<ImGuiCol, float, uint>)vt[92])(idx, alphaMul);
			#endif
		}

		/// <summary>
		/// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		public static uint GetColorU32(ImGuiCol idx, float alphaMul)
		{
			uint ret = GetColorU32Native(idx, alphaMul);
			return ret;
		}

		/// <summary>
		/// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		public static uint GetColorU32(ImGuiCol idx)
		{
			uint ret = GetColorU32Native(idx, (float)(1.0f));
			return ret;
		}

		/// <summary>
		/// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		internal static uint GetColorU32Native(Vector4 col)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)vt[93])(col);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)vt[93])(col);
			#endif
		}

		/// <summary>
		/// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		public static uint GetColorU32(Vector4 col)
		{
			uint ret = GetColorU32Native(col);
			return ret;
		}

		/// <summary>
		/// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		internal static uint GetColorU32Native(uint col, float alphaMul)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, uint>)vt[94])(col, alphaMul);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, float, uint>)vt[94])(col, alphaMul);
			#endif
		}

		/// <summary>
		/// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		public static uint GetColorU32(uint col, float alphaMul)
		{
			uint ret = GetColorU32Native(col, alphaMul);
			return ret;
		}

		/// <summary>
		/// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList<br/>
		/// </summary>
		public static uint GetColorU32(uint col)
		{
			uint ret = GetColorU32Native(col, (float)(1.0f));
			return ret;
		}

		/// <summary>
		/// retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.<br/>
		/// </summary>
		internal static Vector4* GetStyleColorVec4Native(ImGuiCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4*>)vt[95])(idx);
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<ImGuiCol, nint>)vt[95])(idx);
			#endif
		}

		/// <summary>
		/// retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.<br/>
		/// </summary>
		public static Vector4* GetStyleColorVec4(ImGuiCol idx)
		{
			Vector4* ret = GetStyleColorVec4Native(idx);
			return ret;
		}

		/// <summary>
		/// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).<br/>
		/// </summary>
		internal static void GetCursorScreenPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[96])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[96])((nint)pOut);
			#endif
		}

		/// <summary>
		/// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).<br/>
		/// </summary>
		public static Vector2 GetCursorScreenPos()
		{
			Vector2 ret;
			GetCursorScreenPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).<br/>
		/// </summary>
		public static void GetCursorScreenPos(Vector2* pOut)
		{
			GetCursorScreenPosNative(pOut);
		}

		/// <summary>
		/// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).<br/>
		/// </summary>
		public static void GetCursorScreenPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCursorScreenPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.<br/>
		/// </summary>
		internal static void SetCursorScreenPosNative(Vector2 pos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[97])(pos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[97])(pos);
			#endif
		}

		/// <summary>
		/// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.<br/>
		/// </summary>
		public static void SetCursorScreenPos(Vector2 pos)
		{
			SetCursorScreenPosNative(pos);
		}

		/// <summary>
		/// available space from current position. THIS IS YOUR BEST FRIEND.<br/>
		/// </summary>
		internal static void GetContentRegionAvailNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[98])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[98])((nint)pOut);
			#endif
		}

		/// <summary>
		/// available space from current position. THIS IS YOUR BEST FRIEND.<br/>
		/// </summary>
		public static Vector2 GetContentRegionAvail()
		{
			Vector2 ret;
			GetContentRegionAvailNative(&ret);
			return ret;
		}

		/// <summary>
		/// available space from current position. THIS IS YOUR BEST FRIEND.<br/>
		/// </summary>
		public static void GetContentRegionAvail(Vector2* pOut)
		{
			GetContentRegionAvailNative(pOut);
		}

		/// <summary>
		/// available space from current position. THIS IS YOUR BEST FRIEND.<br/>
		/// </summary>
		public static void GetContentRegionAvail(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetContentRegionAvailNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// [window-local] cursor position in window-local coordinates. This is not your best friend.<br/>
		/// </summary>
		internal static void GetCursorPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[99])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[99])((nint)pOut);
			#endif
		}

		/// <summary>
		/// [window-local] cursor position in window-local coordinates. This is not your best friend.<br/>
		/// </summary>
		public static Vector2 GetCursorPos()
		{
			Vector2 ret;
			GetCursorPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// [window-local] cursor position in window-local coordinates. This is not your best friend.<br/>
		/// </summary>
		public static void GetCursorPos(Vector2* pOut)
		{
			GetCursorPosNative(pOut);
		}

		/// <summary>
		/// [window-local] cursor position in window-local coordinates. This is not your best friend.<br/>
		/// </summary>
		public static void GetCursorPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCursorPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		internal static float GetCursorPosXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[100])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[100])();
			#endif
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		public static float GetCursorPosX()
		{
			float ret = GetCursorPosXNative();
			return ret;
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		internal static float GetCursorPosYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[101])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[101])();
			#endif
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		public static float GetCursorPosY()
		{
			float ret = GetCursorPosYNative();
			return ret;
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		internal static void SetCursorPosNative(Vector2 localPos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[102])(localPos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[102])(localPos);
			#endif
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		public static void SetCursorPos(Vector2 localPos)
		{
			SetCursorPosNative(localPos);
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		internal static void SetCursorPosXNative(float localX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[103])(localX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[103])(localX);
			#endif
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		public static void SetCursorPosX(float localX)
		{
			SetCursorPosXNative(localX);
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		internal static void SetCursorPosYNative(float localY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[104])(localY);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[104])(localY);
			#endif
		}

		/// <summary>
		/// [window-local] "<br/>
		/// </summary>
		public static void SetCursorPosY(float localY)
		{
			SetCursorPosYNative(localY);
		}

		/// <summary>
		/// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.<br/>
		/// </summary>
		internal static void GetCursorStartPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[105])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[105])((nint)pOut);
			#endif
		}

		/// <summary>
		/// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.<br/>
		/// </summary>
		public static Vector2 GetCursorStartPos()
		{
			Vector2 ret;
			GetCursorStartPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.<br/>
		/// </summary>
		public static void GetCursorStartPos(Vector2* pOut)
		{
			GetCursorStartPosNative(pOut);
		}

		/// <summary>
		/// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.<br/>
		/// </summary>
		public static void GetCursorStartPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCursorStartPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.<br/>
		/// </summary>
		internal static void SeparatorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[106])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[106])();
			#endif
		}

		/// <summary>
		/// separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.<br/>
		/// </summary>
		public static void Separator()
		{
			SeparatorNative();
		}

		/// <summary>
		/// call between widgets or groups to layout them horizontally. X position given in window coordinates.<br/>
		/// </summary>
		internal static void SameLineNative(float offsetFromStartX, float spacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[107])(offsetFromStartX, spacing);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)vt[107])(offsetFromStartX, spacing);
			#endif
		}

		/// <summary>
		/// call between widgets or groups to layout them horizontally. X position given in window coordinates.<br/>
		/// </summary>
		public static void SameLine(float offsetFromStartX, float spacing)
		{
			SameLineNative(offsetFromStartX, spacing);
		}

		/// <summary>
		/// call between widgets or groups to layout them horizontally. X position given in window coordinates.<br/>
		/// </summary>
		public static void SameLine(float offsetFromStartX)
		{
			SameLineNative(offsetFromStartX, (float)(-1.0f));
		}

		/// <summary>
		/// call between widgets or groups to layout them horizontally. X position given in window coordinates.<br/>
		/// </summary>
		public static void SameLine()
		{
			SameLineNative((float)(0.0f), (float)(-1.0f));
		}

		/// <summary>
		/// undo a SameLine() or force a new line when in a horizontal-layout context.<br/>
		/// </summary>
		internal static void NewLineNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[108])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[108])();
			#endif
		}

		/// <summary>
		/// undo a SameLine() or force a new line when in a horizontal-layout context.<br/>
		/// </summary>
		public static void NewLine()
		{
			NewLineNative();
		}

		/// <summary>
		/// add vertical spacing.<br/>
		/// </summary>
		internal static void SpacingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[109])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[109])();
			#endif
		}

		/// <summary>
		/// add vertical spacing.<br/>
		/// </summary>
		public static void Spacing()
		{
			SpacingNative();
		}

		/// <summary>
		/// add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.<br/>
		/// </summary>
		internal static void DummyNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[110])(size);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)vt[110])(size);
			#endif
		}

		/// <summary>
		/// add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.<br/>
		/// </summary>
		public static void Dummy(Vector2 size)
		{
			DummyNative(size);
		}

		/// <summary>
		/// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w &lt;= 0<br/>
		/// </summary>
		internal static void IndentNative(float indentW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[111])(indentW);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[111])(indentW);
			#endif
		}

		/// <summary>
		/// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w &lt;= 0<br/>
		/// </summary>
		public static void Indent(float indentW)
		{
			IndentNative(indentW);
		}

		/// <summary>
		/// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w &lt;= 0<br/>
		/// </summary>
		public static void Indent()
		{
			IndentNative((float)(0.0f));
		}

		/// <summary>
		/// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w &lt;= 0<br/>
		/// </summary>
		internal static void UnindentNative(float indentW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[112])(indentW);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[112])(indentW);
			#endif
		}

		/// <summary>
		/// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w &lt;= 0<br/>
		/// </summary>
		public static void Unindent(float indentW)
		{
			UnindentNative(indentW);
		}

		/// <summary>
		/// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w &lt;= 0<br/>
		/// </summary>
		public static void Unindent()
		{
			UnindentNative((float)(0.0f));
		}

		/// <summary>
		/// lock horizontal starting position<br/>
		/// </summary>
		internal static void BeginGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[113])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[113])();
			#endif
		}

		/// <summary>
		/// lock horizontal starting position<br/>
		/// </summary>
		public static void BeginGroup()
		{
			BeginGroupNative();
		}

		/// <summary>
		/// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)<br/>
		/// </summary>
		internal static void EndGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[114])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[114])();
			#endif
		}

		/// <summary>
		/// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)<br/>
		/// </summary>
		public static void EndGroup()
		{
			EndGroupNative();
		}

		/// <summary>
		/// vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)<br/>
		/// </summary>
		internal static void AlignTextToFramePaddingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[115])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[115])();
			#endif
		}

		/// <summary>
		/// vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)<br/>
		/// </summary>
		public static void AlignTextToFramePadding()
		{
			AlignTextToFramePaddingNative();
		}

		/// <summary>
		/// ~ FontSize<br/>
		/// </summary>
		internal static float GetTextLineHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[116])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[116])();
			#endif
		}

		/// <summary>
		/// ~ FontSize<br/>
		/// </summary>
		public static float GetTextLineHeight()
		{
			float ret = GetTextLineHeightNative();
			return ret;
		}

		/// <summary>
		/// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)<br/>
		/// </summary>
		internal static float GetTextLineHeightWithSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[117])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[117])();
			#endif
		}

		/// <summary>
		/// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)<br/>
		/// </summary>
		public static float GetTextLineHeightWithSpacing()
		{
			float ret = GetTextLineHeightWithSpacingNative();
			return ret;
		}

		/// <summary>
		/// ~ FontSize + style.FramePadding.y * 2<br/>
		/// </summary>
		internal static float GetFrameHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[118])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[118])();
			#endif
		}

		/// <summary>
		/// ~ FontSize + style.FramePadding.y * 2<br/>
		/// </summary>
		public static float GetFrameHeight()
		{
			float ret = GetFrameHeightNative();
			return ret;
		}

		/// <summary>
		/// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)<br/>
		/// </summary>
		internal static float GetFrameHeightWithSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[119])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[119])();
			#endif
		}

		/// <summary>
		/// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)<br/>
		/// </summary>
		public static float GetFrameHeightWithSpacing()
		{
			float ret = GetFrameHeightWithSpacingNative();
			return ret;
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		internal static void PushIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[120])(strId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[120])((nint)strId);
			#endif
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(byte* strId)
		{
			PushIDNative(strId);
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		internal static void PushIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)vt[121])(strIdBegin, strIdEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[121])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(byte* strIdBegin, byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		public static void PushID(string strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			PushIDNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		internal static void PushIDNative(void* ptrId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)vt[122])(ptrId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[122])((nint)ptrId);
			#endif
		}

		/// <summary>
		/// push pointer into the ID stack (will hash pointer).<br/>
		/// </summary>
		public static void PushID(void* ptrId)
		{
			PushIDNative(ptrId);
		}

		/// <summary>
		/// push string into the ID stack (will hash string).<br/>
		/// </summary>
		internal static void PushIDNative(int intId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[123])(intId);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[123])(intId);
			#endif
		}

		/// <summary>
		/// push integer into the ID stack (will hash integer).<br/>
		/// </summary>
		public static void PushID(int intId)
		{
			PushIDNative(intId);
		}

		/// <summary>
		/// pop from the ID stack.<br/>
		/// </summary>
		internal static void PopIDNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[124])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[124])();
			#endif
		}

		/// <summary>
		/// pop from the ID stack.<br/>
		/// </summary>
		public static void PopID()
		{
			PopIDNative();
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		internal static uint GetIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint>)vt[125])(strId);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)vt[125])((nint)strId);
			#endif
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(byte* strId)
		{
			uint ret = GetIDNative(strId);
			return ret;
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				uint ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				uint ret = GetIDNative((byte*)pstrId);
				return ret;
			}
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		internal static uint GetIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, uint>)vt[126])(strIdBegin, strIdEnd);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)vt[126])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(byte* strIdBegin, byte* strIdEnd)
		{
			uint ret = GetIDNative(strIdBegin, strIdEnd);
			return ret;
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				uint ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				uint ret = GetIDNative((byte*)pstrIdBegin, strIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		/// <summary>
		/// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself<br/>
		/// </summary>
		public static uint GetID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				uint ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}
	}
}
